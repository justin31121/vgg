ROARING BITMAPS

Speichern von 32-Bit Integern.
Datenstruktur von Sets.

Aufteilung in 2^16 Bit-große Chunks.

Der Chunk speichert die MSB Bits.
Der darunter liegende Container speichert die dazugehörigen LSB Bits.

Es gibt zwei verschiedene Arten von Containern. Arrays und Bitmaps.

//Cunks
Chunks halten die MSB + Kardinalität des Containers. Je 16+16 Bit.

//Arrays
Ein sortierter Array von bis zu 4096 16-Bit Integern.
Insgesamt 4069 * 16 Bit = 65 536 Bit.

//Bitmaps
Eine 2^16 = 65 536 Bit große Bitmap.
Ist ein n = 16-Bit Integer enthalten so ist ander Stelle n eine 1.
Sonst 0.
Insgesamt 2^16 Bit = 65 536 Bit.

//=====================================================================

Beispiel: S = {0, 62, 124, ..., 61 938} u {65 536, 65 537, ..., 65 635} u [2 x 2^16, 3 x 2^16)

	  Die ersten 1000-Vielfachen von 62, Die Zahlen von 65 536 bis 65 635 und alle Zahlen geraden
	  Zahlen im Intervall [2 x 2^16, 3 x 2^16).

//Chunk 1: 0x0000 - Array
0, 62, 124, ..., 61 938

//Chunk 2: 0x0001 - Array
0, 1, 2, .. , 99

//Chunk 3: 0x0002 - Bitmap
1, 0, 1, 0, ... , 0

===========>

  size(Chunk) = 2^16 + 32 Bits ~= 8kB

  3 * size(Chunk)
= 3 * 65 536 + 3 * 32
= 196 608 + 96
= 196 752 Bits = 24 594 Bytes => 25 kB

  (1000 + 100 + (65 536/2)) * 32
= 33 868 * 32
= 1 083 776 Bits = 135 472 Bytes => 135 kB


 ~> 196 752 ist 18,15 % von 1 083 776
(+) In der Roaring-Bitmaps-Datanstruktur haben noch weiterer Integer Platz ohne weiteren Speicher zu belegen 

//=====================================================================

//contains

BinarySearch over Chunks with MSB ~> O(log n)
BinarySearch over Container with LSB ~> O(log n)

=> O(log n)

//insert & remove

BinarySearch over Chunks with MSB ~> O(log n)
(BinarySearch on Array ~> O(log n) )
Set Bit in Bitmap/ Integer in Array O(n)

~> O(n)

When after removing or inserting the Container has to change to Array or Bitmap. A new Container is created and the old one is
discarded.


